package fun.jevon.singleton;

/**
 * 单例模式性能排序（从高到低）
 *
 * 性能排序（从高到低）：
 * 1. 饿汉式单例模式（Eager Singleton）⭐⭐⭐⭐⭐
 * 2. 双检锁单例模式（Double-Check Locking Singleton）⭐⭐⭐⭐
 * 3. 懒汉式单例模式（Lazy Singleton）⭐⭐
 *
 * ============================================================================
 * 性能排序详细解释：
 * ============================================================================
 *
 * 【第1名：饿汉式单例模式】⭐⭐⭐⭐⭐
 * 性能：最高
 * 原因：
 * - 类加载时立即创建实例，使用 static final 变量，天然线程安全
 * - 无锁、无同步开销，getInstance() 方法只是简单返回实例
 * - 访问时无任何同步机制，性能最优
 * - 类加载时初始化，JVM 保证线程安全
 * 缺点：
 * - 如果实例创建开销大，且程序运行过程中可能不使用，会浪费资源
 * - 不能延迟加载，即使不使用也会创建实例
 * 适用场景：
 * - 实例创建开销小
 * - 程序启动时就需要使用该实例
 * - 对性能要求极高的场景
 *
 *
 * 【第2名：双检锁单例模式】⭐⭐⭐⭐
 * 性能：高（首次访问有锁，后续无锁）
 * 原因：
 * - 延迟加载：只有在第一次调用时才创建实例
 * - 双重检查：第一次检查避免不必要的加锁，大多数情况下直接返回
 * - 只有第一次创建实例时需要加锁，后续访问无需加锁，性能接近饿汉式
 * - 使用 volatile 保证可见性，防止指令重排序
 * 缺点：
 * - 首次访问需要加锁，有一定的同步开销
 * - 代码相对复杂，需要理解 volatile 和双重检查的含义
 * 适用场景：
 * - 需要延迟加载
 * - 实例创建开销大，不希望程序启动时就创建
 * - 对性能有较高要求，但需要延迟加载的场景
 *
 *
 * 【第3名：懒汉式单例模式】⭐⭐
 * 性能：较低（每次访问都要加锁）
 * 原因：
 * - 延迟加载：只有在第一次调用时才创建实例
 * - 使用 synchronized 方法，每次调用 getInstance() 都要加锁
 * - 即使实例已经创建，后续访问仍然需要加锁，造成不必要的性能开销
 * - 锁竞争激烈时，性能下降明显
 * 缺点：
 * - 每次访问都要加锁，性能开销大
 * - 高并发场景下，锁竞争成为性能瓶颈
 * 适用场景：
 * - 需要延迟加载
 * - 访问频率不高的场景
 * - 对性能要求不高的场景
 *
 * ============================================================================
 * 性能对比总结：
 * ============================================================================
 *
 * 排序	方式	性能特点	同步开销
 * 1	饿汉式单例	无锁访问，最高性能	无
 * 2	双检锁单例	首次加锁，后续无锁	首次访问有锁
 * 3	懒汉式单例	每次访问都要加锁	每次都有锁
 *
 * 核心原因：
 * - 无锁 > 首次加锁后续无锁 > 每次加锁
 *
 * 选择建议：
 * - 如果实例创建开销小，且启动时就需要：优先使用饿汉式
 * - 如果需要延迟加载，且对性能有要求：使用双检锁
 * - 如果访问频率很低，对性能要求不高：可以使用懒汉式
 *
 * 性能差异示例（相对值，仅供参考）：
 * - 饿汉式：基准（1x）- 无锁访问
 * - 双检锁：约 1.1-1.5x（首次访问有锁，后续无锁）
 * - 懒汉式：约 10-50x（每次访问都要加锁）
 *
 * ============================================================================
 * 注意事项：
 * ============================================================================
 *
 * - 饿汉式虽然性能最高，但如果实例创建开销大且可能不使用，会浪费资源
 * - 双检锁必须使用 volatile，否则可能因为指令重排序导致问题
 * - 懒汉式的 synchronized 方法虽然简单，但性能较差
 * - 实际选择时，要考虑延迟加载的需求、实例创建开销、访问频率等因素
 * - 在 Java 5+ 中，也可以使用枚举实现单例，性能接近饿汉式且更简洁
 */
public class SingletonPerformanceRanking {

    /**
     * 性能排序展示
     */
    public static void main(String[] args) {
        System.out.println("=== 单例模式性能排序（从高到低）===\n");

        System.out.println("1. 饿汉式单例模式（Eager Singleton）⭐⭐⭐⭐⭐");
        System.out.println("   → 无锁访问，最高性能\n");

        System.out.println("2. 双检锁单例模式（Double-Check Locking Singleton）⭐⭐⭐⭐");
        System.out.println("   → 首次加锁，后续无锁，性能高\n");

        System.out.println("3. 懒汉式单例模式（加锁版本）（Lazy Singleton）⭐⭐");
        System.out.println("   → 每次访问都要加锁，性能较低\n");

        System.out.println("详细解释请查看类注释中的 @SingletonPerformanceRanking");
        System.out.println("\n示例代码：");
        System.out.println("- EagerSingletonDemo.java - 饿汉式示例");
        System.out.println("- DoubleCheckLockingSingletonDemo.java - 双检锁示例");
        System.out.println("- LazySingletonDemo.java - 懒汉式示例");
    }
}

