package fun.jevon.threadSafety;

/**
 * 线程安全方式性能排序（从高到低）
 * 
 * 注意：这里的"性能"主要指多线程高并发下的执行效率，而不是单线程性能。
 *
 * ============================================================================
 * 性能排序（从高到低）：
 * ============================================================================
 * 1. 局部变量隔离（Thread-Local / 栈封闭）⭐⭐⭐⭐⭐⭐
 * 2. 不可变对象（Immutable Object）⭐⭐⭐⭐⭐
 * 3. 原子类（Atomic 系列）⭐⭐⭐⭐
 * 4. 并发容器（java.util.concurrent 包）⭐⭐⭐
 * 5. 互斥锁（synchronized / ReentrantLock）⭐
 * 6. 并发控制机制（同步工具类）⭐⭐
 *
 * ============================================================================
 * 性能排序详细解释：
 * ============================================================================
 *
 * 【第1名：局部变量隔离（Thread-Local / 栈封闭）】⭐⭐⭐⭐⭐⭐
 * 性能：最高
 * 原因：
 * - 每个线程拥有自己独立的变量副本，操作完全不共享，无需加锁、无需同步。
 * - CPU 缓存友好（数据局部性好），不会出现竞争，也不存在阻塞。
 * - 方法内局部变量存储在栈帧中，天然线程私有。
 * - ThreadLocal 虽然需要哈希表查找，但开销极小（O(1)）。
 * - 无锁、无阻塞、无CAS重试，完全并行执行。
 * 适用场景：
 * - 每个线程只需要自己的数据，例如 ThreadLocal 保存用户上下文信息、数据库连接等。
 *
 *
 * 【第2名：不可变对象（Immutable Object）】⭐⭐⭐⭐⭐
 * 性能：非常高
 * 原因：
 * - 不可变对象的数据不变，线程只读，天然线程安全。
 * - 没有同步开销，不需要锁或原子操作。
 * - 无锁、无阻塞、无CAS，完全并行读取。
 * 适用场景：
 * - String、Integer 等包装类，或者自定义不可变对象（如 Point、LocalDateTime 等）。
 * ⚠️ 注意：
 * - 如果频繁创建新的不可变对象（如修改返回新对象），会有 GC 开销，影响性能。
 *
 *
 * 【第3名：原子类（Atomic 系列）】⭐⭐⭐⭐
 * 性能：高
 * 原因：
 * - 基于 CAS（Compare-And-Swap）实现，不用传统锁，CPU 提供硬件级原子性保证。
 * - 对单个变量操作原子，避免线程阻塞。
 * - 无锁设计，不会阻塞线程，高并发下性能优秀。
 * - 比锁机制开销小得多，因为不需要线程阻塞/唤醒和上下文切换。
 * 适用场景：
 * - 高并发计数器（AtomicInteger）、状态标记等。
 * 注意事项：
 * - CAS 会自旋重试，如果竞争非常激烈，性能可能下降。
 *
 *
 * 【第4名：并发容器（java.util.concurrent 包）】⭐⭐⭐
 * 性能：中高
 * 原因：
 * - 内部使用细粒度锁或 CAS + 分段锁等机制，允许多线程同时访问不同的段/桶。
 * - ConcurrentHashMap：分段锁或CAS，减少锁竞争。
 * - CopyOnWriteArrayList：写时复制，读无锁，但写操作有复制开销。
 * - ConcurrentLinkedQueue：无锁队列，但涉及指针操作和内存屏障。
 * - 比传统全锁容器（如 Collections.synchronizedList）效率高。
 * - 相比原子类，操作更复杂（可能涉及多次CAS或多段访问）。
 * 适用场景：
 * - 高并发的集合操作，如 ConcurrentHashMap、CopyOnWriteArrayList。
 * 缺点：
 * - 仍然存在部分锁或复制开销，尤其写操作比读操作开销大（例如 CopyOnWriteArrayList 写操作会复制数组）。
 *
 *
 * 【第5名：互斥锁（synchronized / ReentrantLock）】⭐
 * 性能：中
 * 原因：
 * - 每次访问共享资源都需要获取锁，可能阻塞等待。
 * - synchronized：可能涉及JVM级别的重量级锁（Monitor），线程阻塞/唤醒开销大。
 *   但 JVM 对 synchronized 做了优化（偏向锁、轻量级锁），但竞争激烈时仍有上下文切换开销。
 * - ReentrantLock：虽然灵活（可中断、可公平、可超时），但同样需要阻塞/唤醒。
 *   支持公平锁、不公平锁，可做条件等待，灵活性高，但也有 CAS 自旋和阻塞开销。
 * - 锁竞争激烈时，大量线程阻塞等待，上下文切换频繁。
 * - 临界区串行化执行，无法并行，是性能瓶颈。
 * 适用场景：
 * - 复杂的临界区、需要互斥保护的共享资源、需要锁的灵活特性时。
 * - 临界区访问复杂逻辑或多个变量，或者需要公平性/条件变量。
 *
 *
 * 【第6名：并发控制机制（CountDownLatch / Semaphore / CyclicBarrier 等）】⭐⭐
 * 性能：较低
 * 原因：
 * - 这种机制本质是线程协调工具，会阻塞线程、挂起等待其他线程完成条件。
 * - CPU 上需要线程等待和唤醒，存在上下文切换开销。
 * - CountDownLatch、Semaphore、CyclicBarrier等需要线程阻塞/唤醒。
 * - 涉及操作系统级别的线程调度，有上下文切换开销。
 * - 性能开销主要来自阻塞/唤醒，而不是同步本身。
 * 适用场景：
 * - 线程协作、任务同步、限流等。
 * 注意：
 * - 不适合频繁操作的高性能临界区，只做线程间协调。
 *
 * ============================================================================
 * 性能对比总结：
 * ============================================================================
 *
 * 排序	方式	性能特点
 * 1	局部变量隔离（ThreadLocal / 栈封闭）	无锁、无阻塞，最高效
 * 2	不可变对象（Immutable Object）	无锁只读，效率很高
 * 3	原子类（AtomicXXX）	CAS 原子操作，无阻塞，高并发下效率高
 * 4	并发容器（ConcurrentXXX）	细粒度锁或段锁，允许多线程并发访问
 * 5	互斥锁（synchronized / ReentrantLock）	阻塞等待，线程切换开销，性能中等
 * 6	并发控制机制（Semaphore / CountDownLatch / Barrier）	阻塞协调线程，上下文切换开销大，性能相对低
 *
 * 核心原因：
 * - 无竞争 > 只读 > CAS无锁 > 分段优化 > 阻塞锁 > 线程协调阻塞
 *
 * 选择建议：
 * - 优先考虑：能否用局部变量隔离或不可变对象？
 * - 其次考虑：能否用原子类解决？
 * - 再次考虑：能否用并发容器？
 * - 最后选择：互斥锁或同步工具（最通用但性能较差）
 *
 * 性能差异示例（相对值，仅供参考）：
 * - 局部变量隔离：基准（1x）
 * - 不可变对象：约 1.1x（略微开销）
 * - 原子类：约 2-5x（CAS开销）
 * - 并发容器：约 5-10x（复杂操作）
 * - 互斥锁：约 10-50x（阻塞/唤醒、上下文切换）
 * - 并发控制机制：约 50-200x（阻塞协调、上下文切换）
 *
 * ============================================================================
 * 注意事项：
 * ============================================================================
 *
 * - 性能排序是相对的，实际性能取决于具体场景、并发度、竞争程度。
 * - 高并发场景下，原子类可能优于锁机制数十倍。
 * - 低竞争场景下，各种方式的性能差异可能不明显。
 * - 选择线程安全方式时，不仅要考虑性能，还要考虑正确性、可维护性。
 * - 优先选择最简单、最易理解的方式，在性能确实成为瓶颈时再优化。
 */
public class ThreadSafetyPerformanceRanking {
    
    /**
     * 性能排序展示
     */
    public static void main(String[] args) {
        System.out.println("=== 线程安全方式性能排序（从高到低）===\n");
        System.out.println("注意：这里的性能主要指多线程高并发下的执行效率，而不是单线程性能。\n");
        
        System.out.println("1. 局部变量隔离（Thread-Local / 栈封闭）⭐⭐⭐⭐⭐⭐");
        System.out.println("   → 无锁、无阻塞，最高效\n");
        
        System.out.println("2. 不可变对象（Immutable Object）⭐⭐⭐⭐⭐");
        System.out.println("   → 无锁只读，效率很高\n");
        
        System.out.println("3. 原子类（AtomicXXX）⭐⭐⭐⭐");
        System.out.println("   → CAS 原子操作，无阻塞，高并发下效率高\n");
        
        System.out.println("4. 并发容器（ConcurrentXXX）⭐⭐⭐");
        System.out.println("   → 细粒度锁或段锁，允许多线程并发访问\n");
        
        System.out.println("5. 互斥锁（synchronized / ReentrantLock）⭐⭐");
        System.out.println("   → 阻塞等待，线程切换开销，性能中等\n");
        
        System.out.println("6. 并发控制机制（Semaphore / CountDownLatch / Barrier）⭐");
        System.out.println("   → 阻塞协调线程，上下文切换开销大，性能相对低\n");
        
        System.out.println("详细解释请查看类注释中的 @ThreadSafetyPerformanceRanking");
    }
}
